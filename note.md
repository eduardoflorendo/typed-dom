# Note

ArchStreamはJavaScriptによるドメイン駆動設計（DDD）およびデータ指向設計のためのライブラリである。
依存関係の事前条件への変換、依存関係の直列化および依存関係数制限によりシーケンスの依存関係が保証されたアーキテクチャを構築する。
モジュールの利用、実行時に参照する情報および情報の処理分担を宣言的に制約することで分割された各機能およびコンポーネントを保守拡張するために必要となる知識を当該箇所に局所化し最小化する。

ArchStreamが設計に代表される静的問題解決を担うほか、ジョブ・集合・コンポーネントの生成管理などの動的問題解決をSupervisorが担う。
このライブラリはストリーム以外にメッセージング、タイマー、バックグラウンドスレッド代用のSupervisorとObserverなどドメイン駆動設計に必要となる機能をまとめたDDD用ツールボックスとなっている。
入出力の調整など信号処理的な機能はlodashなどの外部のデータ処理系ライブラリに委ねている。

## 性質

エンティティの運搬とストリームのモジュール化に特化しており、エンティティの型と参照を経路で変更できず、入出力箇所をそれぞれ1つしか持たない厳格なパイプラインを構築する。
ストリームは原則として独立したモジュールとなるモジュラーストリームへ変換して管理し、これを合成することでパイプラインを構築する。
Stream APIやUnderscoreがデータ操作、RxJSがSmartUI（View）をターゲットにしているのに対して、ArchStreamはアーキテクチャ設計（Model）をターゲットにしている。

## 用語

### ストリーム

インポート・エクスポート前のArchStreamのストリーム。
ストリームデータを処理する関数を定義可能な唯一のストリーム。

または、包括的な意味でのストリーム。

### コンポースストリーム

インポート後エクスポート前のストリーム。
合成先となる唯一のストリーム。

### モジュラーストリーム

エクスポート後のストリーム。
合成元となる唯一のストリーム。
入出力可能な唯一のストリーム。

### プロキシ

ストリームを拡張する機能。
同一のメソッドに対する多重適用が可能。
ビルトインプロキシがいくつか存在する。

### パイプライン

意味のある単位まで構築され入出力の行われるストリーム。
モジュラーストリームのみで構成される。
構築時点で経路が固定され動的に変更されない。
エンティティの種類ごとに構築すべきものとなる。
メソッドを条件付きインポートで表現する。

### エンドポイント

具体的な処理を定義可能な前述のストリーム。

### エンティティ

パイプラインの入出力単位。
エンティティは唯一性を持たなければならず、エンティティ同士の等価比較は常に偽とならなければらない。
エンティティはパイプライン内で置換されることも喪失されることもない。

### 型不変

ArchStreamのパイプラインはエンティティのみを入出力とするため入出力でエンティティの型が異なることが許されない型不変の設計である。

### 参照不変

ArchStreamのパイプラインはエンティティのみを入出力とするため入出力でエンティティの同一性が異なることが許されない参照不変の設計である。

### 静的構造

パイプラインの構造。
パイプラインは構築時点で経路が固定され動的に変更されないため実行時に処理を追跡せずとも静的に評価可能となる。
運搬責務分離によりこの静的構造部分は処理を持たないため、静的構造をたどって分割統治された各部の処理まで到達したあとは静的構造を意識から除外してエンドポイントに定義された関数のみを評価できる。

### 運搬責務分離

後述。

### 運搬責務区分

パイプライン部分。

### 実体定義区分

パイプラインに定義された関数部分。

## 目的

### 厳格なパイプラインによるシーケンスの実装とエンティティデータおよび型不変の強制

ストリームによりエンティティを終端まで運び、経路の知識によりコマンドの実行やクエリ結果の挿入といった処理を行う。
ストリームのエンティティの型は不変であり経路で型を変更できない。
ストリームのメソッドはコールバックの戻り値を無視し経路でエンティティの参照（実体の同一性）を変更できない。
ストリームの入出力はそれぞれ1箇所のみに限定され複数の入出力を作ることができない。
シーケンス図で書くような直線的な順次処理が中心となるアプリケーションに適している。
ユーザーとサービスコンテンツのように、エンティティの種類が異なる場合はエンティティの種類ごとにパイプラインを用意する。
入出力を各1箇所に限定し、パイプラインがエンティティの種類ごとに構築するものである都合上、独立した多数の機能やアクセスポイントの提供を目的とするモデルへの適用は難しい。
目安として入力データが概ね情報量を減らさずに処理の大部分を通過するようなデータ処理的なレイヤーに適しており、
反対に入力データを分解して浸透させるまたは処理を駆動させるような副作用を主体とするレイヤーには適していない。

### 運搬責務分離

プログラムの具体的処理を記述する関数を依存関係の最深部に凝集し、
それ以外の中継的な関数を最深部の関数までエンティティを運搬することにのみ責務を負わせて関数の責務を分離することで真に依存関係があり呼びだされる関数の数とその組み合わせサイズを最小化する。
CQRSが垂直方向の分離とすると運搬責務による分離は水平方向の分離となる。

依存関係を木構造で表すならば、ノードがモジュラーストリームのみ存在する運搬責務区分、リーフが具体的処理実体の定義である関数とそれを追加するストリームのみ存在する実体定義区分に区分される。
運搬責務区分の関数はパイプラインの安定的な静的構造を構築する以外の機能を持たないため実体定義区分である末端のモジュールに個別に関心を持つ際に上部の運搬責務区分の中を見る必要がない。
ストリームの実装においても末端の処理が集積されるルート以外のモジュラーストリームはパイプライン構築後の稼動時において何の機能も持たず実質的に空のストリームであり、
運搬責務区分の関数は構築時にしか使用されないため稼動時には実質的に消滅し、実体定義区分の関数だけが残る。
依存関係の木構造はディレクトリー構造と一致させると依存関係を管理しやすい。

### 関心対象の局所化

ストリームをまたいだ依存関係がimport/exportメソッドのみで構築される運搬責務区分である安定的な静的構造にのみ存在するため広域の依存関係の管理が容易となる。
運搬責務分離により運搬以外の実際の処理を記述している関数が各構造の最深部に凝集されるため、
非構造変更的な修正と拡張に必要な知識を得るために把握しなければならない範囲もそこに局所化され、パイプラインの構築以外に何も行わない運搬責務区分の関数を意識する必要がなくなる。

### 1ストリーム1オブジェクトの責務分配

あるコマンドまたはクエリの実行と結果など、1つのデータセットの作成を1つのストリームで完結させ、1つのオブジェクトに完成させる。
データセットの作成に必要なすべての知識が少なくとも1つのストリーム内で完結する。
データセットの初期値とパラメーターは外部で持つ。

### 依存関係の事前条件への変換

運搬責務分離により運搬責務区分へ移管された依存関係は安定的な静的構造の一部となり、パイプラインの稼動時に実質的に消滅する箇所でもあるため、
平時の非構造変更的修正においてこの依存関係を意識から除外できるようになり、この依存関係を単なる事前条件とみなせる。
こうした他のストリームへ分離隠蔽された依存関係の適用を自身のストリーム内で確認するには当該依存関係担当箇所のデータが要件を満たすことを事前条件として表明すれば足り、依存関係は各構造の最深部に分割して凝集隔離隠蔽される。

### 依存関係の直列化と保証

パイプラインを構成するモジュールの依存関係は直列となるため各依存関係が直前の依存関係を事前条件により表明することですべての依存関係が求める順序で満たされていることが保証される。
モジュラーストリームはデフォルトで1回しか合成できないため、このときパイプラインを構成するモジュールの依存関係がパイプライン内で完結密閉され外部に流失していないことも保証される。
複数回の合成においても合成回数を指定することで依存関係を意図せず拡散して張り巡らされないよう管理下に置ける。

依存関係の構成要素であるモジュールは合成回数の制約がある都合上個別にテストできない。
ストリームのテストはモジュール全体であるパイプラインのブラックボックステストとこれを構成する各モジュールのホワイトボックステストを組み合わせることになる。

### 複雑化の防止

入出力ともに1つに固定された単一のパイプラインの順次処理で表現することで各工程で必要な処理を明確化し、依存関係と分岐処理の組み合わせサイズの増大を抑える。
内部APIの使用される組み合わせがパイプラインにより固定されるため、テストにおいてAPIの組み合わせを網羅する必要がなく、パイプラインに対してユニットテストを行えば足りる。
モジュラーストリームは複雑化の回避のためデフォルトで1回しか合成できないよう制限されている。

### 疎結合化

運搬責務分離と依存関係の直列化により各部の処理が分割統治され疎結合化する。

### 設計規約とそのLint

これらの制約と推奨事項は設計の詳細を適切な粒度と責務のモジュールへ分割するための設計規約として機能し、制約は設計規約を強制する設計用Lintとして機能する。

### コルーチン化

Thenableオブジェクトによる非同期処理を任意に組み込め、チェイン単位のコルーチン的な使用に対応する。

## 特徴と制約

- Nodeとブラウザーの両方で動作するがブラウザーアプリケーションをメインターゲットとする。
- 出力を読み込めるのは1関数のみで2つ以上の関数に出力することはできない。
- 入出力データにエンティティを使用することを前提としており、接続するすべてのストリームの型が同じでなければならない。
- 入出力データの参照（同一性）は不変であり、データを置換することはできず、出力から結果を得るには入出力データのプロパティに結果を格納するほかない。
- Thenableオブジェクトは直接入出力データに使用できず、エンティティでラップする必要がある。
- モジュラーストリームはデフォルトで1回しか合成できない。
- 条件付きインポートはパイプライン全体のうち1ストリームでしか行えない。
- 同期処理であるため1チェインごとに遅延されるStream APIより1000倍程度高速となる。
- チェインがコールスタックを消費せずチェイン数の制限がない。

## API

### ArchStream

ストリームを生成する。

```ts
import A from 'arch-stream';

A();
```

#### #pipe

ストリームに処理を定義する。

```ts
A<{val: number}>()
  .pipe(e => e.val = Math.abs(e.val))
  .pipe(e => ++e.val);
```

#### #export

モジュラーストリームを生成する。
デフォルトで1回しか合成できず、複数回合成可能するにはexport時に回数を指定する必要がある。

```ts
const add1 =
  A<{val: number}>()
    .pipe(e => ++e.val)
    .export();
```

#### #import

モジュラーストリームを合成する。
メソッドを条件付きインポートで表現する。

```ts
const stream =
  A<{val: number}>()
    .import(add1)
    .export();
```

#### #read

モジュラーストリームの出力を読む。
1つのリスナーのみ登録できる。
過去の出力は再出力しない。

```ts
stream
	.read(e => console.log(e.val))
```

#### #write

モジュラーストリームへ入力する。

```ts
stream
	.read(e => console.log(e.val))
  .write({val: 1}) // => 1
  .write({val: 2}) // => 2
```

```ts
stream
	.read()
	.write({val: 1}, e => console.log(e)) // => 1
	.write({val: 2}, e => console.log(e)) // => 2
```

#### #proxy

プロキシによりストリームのAPIを拡張する。
任意のプロキシによりAPIを追加および変更することができる。
ストリームの型の拡張が不完全なため複数プロキシ適用時のメソッドの型情報が誤っている場合がある。

後述のビルトインプロキシを提供している。

#### #flow

ストリームの流量を制御する。処理中のデータ量と待機中のキューデータ量を個別に管理する。
あふれたデータを処理するdischargerは同時処理可能なデータ数を超えて入力されるごとに1回、キューの上限を超えると上限内に収まるまで繰り返し呼ばれる。
入力があふれた場合に任意のキューを消したり、文脈解釈とあわせて処理中の任意のデータのステートを変更して以降の処理をキャンセルするといった対応が可能。
Nodeのための機能。クライアントブラウザーでは基本使わなくてよい。なのでやっつけ実装。

```ts
A<number>()
  .pipe(_ => Promise.resolve())
  .export()
  .flow(1, 2, (q, p) => q.length + p.length > 2 && q.shift())
  .read(n => console.log(n))
  .write(1) // => 1
  .write(2)
  .write(3);// => 3
```

### Message

ごくシンプルなPromise代用の非同期処理用オブジェクト。
明示に処理を遅延させなければ同期処理となる。

```ts
import A, { Msg, Message } from 'arch-stream';

A.Msg();
Msg();
new Message();

const msg = A.Msg<number>();
msg.recv(n => console.log(n));
setTimeout(_ => msg.send(1), 1);
```

#### #send

データを入力する。
第二引数に`true`を指定すると非同期処理となる。
第二引数または第三引数に関数を渡すと全処理の完了後に呼び出される。

#### #recv

出力を読む。

#### #trans

出力を置換する。

### Proxy

- ストリームのAPIを拡張する。
- カスタムプロキシを作成することで任意の拡張が可能。
- 同一のAPIの拡張は適用順に多重適用される。
- pipeメソッドがすべての拡張の基底となり、pipeメソッドの拡張はすべてのメソッドに適用される。
- メソッド名は先頭または末尾がアンダースコアであってはならない。
- importメソッドを拡張することはできない。
- exportメソッドの拡張は基底のメソッドの実行後にexportメソッドを呼びだす。
- 以下のビルトインプロキシのファクトリメソッドを提供している。

#### Case

文脈解釈を行う。

#### Hook

事前処理と事後処理を追加する。

#### Responsibility

ストリームの責務オブジェクトを定義する。
責務オブジェクトはエクスポートメソッド通過時に不変化される。

### Supervisor

- タスクやコンポーネントを擬似プロセスとして個別管理する。
- 擬似プロセスの生成(`exec`)・消滅(`exit`)、メッセージの配信失敗(`fail`)・喪失(`loss`)をイベントとして通知する。
- 擬似プロセスは捕捉可能なクラッシュ、Promiseの失敗文脈またはコマンドにより終了する。
- 擬似プロセスは循環可能な依存関係を名前単位で設定でき、すべての依存関係を満たしているときのみメッセージを受信する。
- 擬似プロセスは1以上の並列数を指定しない限り処理中に新たに処理を開始しない。
- メッセージの送信方法は同期送信または非同期送信から選択する。
- メッセージの同期送信は受信者不要であり、受信されなかったメッセージは喪失イベントを発行せずに喪失する。
- メッセージの非同期送信は受信者必須であり、受信されなかったメッセージはタイムアウトまで受信を待機する。
- メッセージの非同期送信は個別にタイムアウトを設定できる。
- 未到達非同期送信メッセージはタイムアウトにより喪失する。
- 未到達非同期送信メッセージはスーパーバイザの終了により喪失する。

スーパーバイザはコンポーネントの管理に適しているが、コンポーネントの実装には向かない。
スーパーバイザは把握困難な無数の状態と不測の事態をクラッシュを制御下に収めることで制御可能にしようとするアプローチだが、
もともと少数の状態しか持たないか状態が無く例外に頼らず実装すべき機能やモジュールをスーパーバイザのエラー耐性に甘えて実装すると
状態管理を放棄したバグありきの劣悪な実装になる。
よって個々の機能やモジュールはシーケンスを完全に制御する従来どおりの方法で実装し、
状態や経路が無数に生じる制御困難な問題に対してのみスーパーバイザで制御を試みることが望ましい。
設計および実装はスーパーバイザの使用の有無にかかわらず状態を収束させる方向に進まなければならない。
スーパーバイザの使用は状態を使用前より収束させるものでなければならず、発散させてはならない。

### Observable

- 出版購読モデルのメッセージングを行う。
- 同期メッセージングに特化しておりサブスクライバのエラーにより停止しない。
- 配列またはセパレータの設定によりjQueryと同等のネームスペースを使用できる。

メッセージを同期処理で即座に配信する。
サブスクライバをノードとして扱い動的な処理経路の構築や集合操作にも利用できる。

### Map/Set

Map/Setの代替API。

### Tick

process.nextTickの代替API。
setTimeoutより先に呼ばれやすい。

### Timer

多条件タイマー。

### FINGERPRINT

9桁以下の整数値。

### uuid

Math.random()とFingerprintをもとにUUIDを生成する。

### sqid

シーケンシャルなIDを生成する。
IDは1からインクリメントする数値を0パディングで15桁にそろえた文字列である。

### Maybe

Maybeモナド。

### Either

Eitherモナド。
