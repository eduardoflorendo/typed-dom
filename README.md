# typed-dom

[![Build Status](https://travis-ci.org/falsandtru/typed-dom.svg?branch=master)](https://travis-ci.org/falsandtru/typed-dom)

Static typed DOM component builder.

**Visualize** DOM structures and **Assist** DOM access by static types of TypeScript.

## APIs

### HTML: { [tagname]: (attrs?, children?, factory?) => ProxyElement };

- attrs: Record<string, string | EventListener>
- children: undefined | string | ProxyElement[] | Record<string, ProxyElement>
- factory: () => Element

```ts
import { HTML } from 'typed-dom';

HTML.p();
HTML.p('text');
HTML.p([HTML.a()]);
HTML.p({ link: HTML.a() }]);
HTML.p({ id: 'id' });
HTML.p(() => document.createElement('p'));
```

### SVG: { [tagname]: (attrs?, children?, factory?) => ProxyElement };

- attrs: Record<string, string | EventListener>
- children: undefined | string | ProxyElement[] | Record<string, ProxyElement>
- factory: () => Element

```ts
import { SVG } from 'typed-dom';

SVG.svg();
```

## Extend APIs

You can define some custom elements by extending `HTMLElementTagNameMap` or `SVGElementTagNameMap_` interface.

```ts
import { HTML, SVG } from 'typed-dom';

declare global {
  interface HTMLElementTagNameMap {
    'custom': HTMLElement;
  }
  interface SVGElementTagNameMap_ {
    'a': SVGAElement;
  }
}

HTML.custom().element.outerHTML; // '<custom></custom>'
SVG.a().element; // SVGAElement
```

## Usage

Build a typed DOM object with styling.

```ts
import { HTML } from 'typed-dom';

const component = HTML.article({
  style: HTML.style(`$scope ul { width: 100px; }`),
  title: HTML.h1(`title` as string),
  content: HTML.ul([
    HTML.li(`item` as string),
    HTML.li(`item`),
  ])
});
```

Then this component has the following static type generated by type inference.

```ts
type ComponentTypeIs =
El<"article", Element, {
  style: El<"style", HTMLStyleElement, string>;
  title: El<"h1", HTMLHeadingElement, string>;
  content: El<"ul", HTMLUListElement, El<"li", HTMLLIElement, string>[]>;
}>;

// Note: El type is defined as follows.
export interface El<
  T extends string,
  E extends Element,
  C extends ElChildren
  > {
  readonly element: E;
  children: C;
}
type ElChildren
  = ElChildren.Void
  | ElChildren.Text
  | ElChildren.Collection
  | ElChildren.Record;
namespace ElChildren {
  export type Void = undefined;
  export type Text = string;
  export type Collection = El<string, Element, any>[];
  export type Record = { [field: string]: El<string, Element, any>; };
}
```

You can know the internal structure via this type which can be used as the visualization.
And you can access and manipulate safely the internal structure guided by this type.

```ts
// inspect
component.element.outerHTML; // '<article class="RANDOM"><style>.RANDOM ul { width: 100px; }</style><h1>title</h1><ul><li>item</li><li>item</li></ul></article>'
component.children.title.element.outerHTML; // '<h1>title</h1>'
component.children.title.children; // 'title'
component.children.content.element.outerHTML; // '<ul><li>item</li><li>item</li></ul>'
component.children.content.children[0].children; // 'item'

// update
// - text
component.children.title.children = 'Title';
component.children.title.element.outerHTML; // '<h1>Title</h1>'

// - collection
component.children.content.children = [
  HTML.li('Item')
];
component.children.content.element.outerHTML; // '<ul><li>Item</li></ul>'

// - HTML
component.children.title = HTML.h1('Title!');
component.children.content = HTML.ul([
  HTML.li('Item!')
]);
component.element.outerHTML; // '<article class="RANDOM>"><style>.RANDOM ul { width: 100px; }</style><h1>Title!</h1><ul><li>Item!</li></ul></article>'
```

## Examples

### DOM Components

Create DOM components.

```ts
import { Shadow, HTML, El } from 'typed-dom';

class Component implements El {
  private readonly dom = HTML.div({
    style: HTML.style(`$scope ul { width: 100px; }`),
    content: HTML.ul([
      HTML.li(`item`)
    ]),
  });
  public readonly element = this.dom.element;
  public get children() {
    return this.dom.children.content.children;
  }
  public set children(children) {
    this.dom.children.content.children = children;
  }
}
class ShadowComponent implements El {
  private readonly dom = Shadow.section({
    style: HTML.style(`ul { width: 100px; }`),
    content: HTML.ul([
      HTML.li(`item`)
    ]),
  });
  public readonly element = this.dom.element;
  public get children() {
    return this.dom.children.content.children;
  }
  public set children(children) {
    this.dom.children.content.children = children;
  }
}
```

## Dependencies

- unassert (in compiling source code)
